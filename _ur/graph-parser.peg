{
  const DQUO='"';
  const SQUO="'";
  function stripQuotes(str) {
    if (str.startsWith(DQUO) && str.endsWith(DQUO)) return str.slice(1,-1);
    if (str.startsWith(SQUO) && str.endsWith(SQUO)) return str.slice(1,-1);
    return str;
  }
}

Start
  = content:Line* !. { return content }

Line
  = BlankLine
  / Comment
  / Command2

BlankLine
  = NL { return { blank:true }}

Comment
  = "//" _ cmt:(!NL .)* NL {
    return { comment: cmt.map(e=>e[1]).join('') }
  }

Command
  = node:Node edges:(!NL .)* NL {
  	return { 
      node,
      edges
    } 
  }

Command2
  = node:Node edges:EdgeList2  {
  	return { 
      node,
      edges
    } 
  }

EdgeList
  = list:(!NL .)* { 
      // return the entire list of edgenames as string with , in them
      return list.map(e=>e[1]).join('');
  }

EdgeList2
  = req:(!EdgeDL !NL .)+ NL { return [req.map(e=>e[2]).join('')] }
  / req:(!EdgeDL .)+ opt:(EdgeDL (!EdgeDL !NL .)*)* NL {
    let terms = [];
    // first term
    terms.push(req.map(arg=>arg[1]).join('')); 
    // additional terms that matched
    opt.forEach(match=>{
      // match is [string,array<array>]]
      let term = match[1].map(chs=>chs[2]).join('');
      term = stripQuotes(term);
      terms.push(term);
    });
    return terms;
  }
  
Node 
  = name:(!NodeDL .)* NodeDL { return name.map(e=>e[1]).join('') }

NodeDL = ':'
EdgeDL = ','

NL = "\r\n" / "\n" / "\r"  
_ "opt whitespace"
  = [ \t]*  
